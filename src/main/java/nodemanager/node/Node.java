package nodemanager.node;

import java.util.*;
import nodemanager.gui.mapComponents.NodeIcon;


/**
 * The Node class is used to store data pertaining to points on campus.
 * Each Node has a unique ID, 
 * x and y coordinates on both a "source plane" and a target Container element, 
 * and the IDs of Nodes connecting to it, known as "adjacent nodes"
 * 
 * These adjacent nodes (edges) are stored in Graph
 * 
 * @author Matt Crow (greengrappler12@gmail.com)
 * @see nodemanager.model.Graph
 */
public class Node {
    public final int id;
    
    /*
    position on a "source plain", which basically means this point can be 
    ANY set of horizontal and vertical components on
    ANY two dimensional grid, so long as x grows right, and y grows down
    */
    private final int initialX;
    private final int initialY;
    
    private int x;
    private int y;
    
    private ArrayList<String> labels; //rooms, buildings, etc.
    private NodeIcon icon;
    
    public Node(int id, int x, int y){
        this.id = id;
        initialX = x;
        initialY = y;
        this.x = x;
        this.y = y;
        icon = new NodeIcon(this);
        icon.setPos(x, y);
        labels = new ArrayList<>();
        icon = new NodeIcon(this);
    } 
       
    public final int getId(){
        return id;
    }
    
    public void setX(int x){
        this.x = x;
    }
    public void setY(int y){
        this.y = y;
    }
    
    /**
     * the x coordinate of this Node on the source plane
     * @return the x coordinate of this Node on the source plane
     */
    public int getX(){
        return x;
    }
    
    public final int getImportedX(){
        return this.initialX;
    }
    
    /**
     * the y coordinate of this Node on the source plane
     * @return the y coordinate of this Node on the source plane
     */
    public int getY(){
        return y;
    }
    
    public final int getImportedY(){
        return this.initialY;
    }
    
    
    /**
     * Adds a label to this node
     * @param s the label to add (room number, building name, etc)
     * @return whether or not the label was successfully added
     */
    public boolean addLabel(String s){
        labels.add(s.toUpperCase());
               
        return true;
    }
    
    
    /**
     * Removes a label from this,
     * if it has the given label,
     * ignoring case
     * @param s the label to remove
     * @return whether or not a label was removed 
     */
    public boolean removeLabel(String s){
        boolean found = false;
        for(int i = 0; i < labels.size() && !found; i++){
            if(labels.get(i).equalsIgnoreCase(s)){
                found = true;
                labels.remove(i);
                //labelToNode.remove(s.toUpperCase());
            }
        }
        return found;
    }
    
    public String[] getLabels(){
        return Arrays.copyOf(labels.toArray(), labels.size(), String[].class);
    }
    
    /**
     * checks if this node has the given label,
     * ignoring case.
     * 
     * @param label the label to search for
     * @return if this has the given label, ignoring case
     */
    public boolean getHasLabel(String label) {
        return labels.stream().anyMatch(l -> l.equalsIgnoreCase(label));
    }
    
    /**
     * Returns the visual representation of this Node.
     * @return the NodeIcon generated by this node
     */
    public NodeIcon getIcon(){
        return icon;
    }
    
    /**
     * Updates this' position to match that of its icon
     */
    public void update(){
        x = (int)icon.getScale().inverseX(icon.getX());
        y = (int)icon.getScale().inverseY(icon.getY());
    }
    
    @Override
    public String toString(){
        return String.format("Node#%d: (%d, %d)", id, x, y);
    }
}
